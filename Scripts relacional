/* =============================================
   RECORD para Cabecera de Orden
   ============================================= */

DECLARE
    -- Definir tipo RECORD para la orden (sin productos)
    TYPE r_orden_type IS RECORD (
        orden_id        NUMBER,
        fecha_creacion  DATE,
        usuario_id      NUMBER,
        nombre_cliente  VARCHAR2(100),
        email_cliente   VARCHAR2(100),
        total           NUMBER(10,2),
        estado          VARCHAR2(20)
    );
    
    -- Declarar variable del tipo RECORD
    v_orden r_orden_type;
    
BEGIN
    -- Obtener datos de una orden especÃ­fica
    SELECT 
        o.id,
        o.creado_en,
        o.id,
        u.nombre,
        u.email,
        o.total,
        o.estado
    INTO v_orden
    FROM ordenes o
    JOIN usuarios u ON o.id = u.id
    WHERE o.id = 1;
    
    -- Imprimir datos del RECORD
    DBMS_OUTPUT.PUT_LINE('=== INFORMACIÃ“N DE LA ORDEN ===');
    DBMS_OUTPUT.PUT_LINE('ID Orden: ' || v_orden.orden_id);
    DBMS_OUTPUT.PUT_LINE('Fecha: ' || TO_CHAR(v_orden.fecha_creacion, 'DD/MM/YYYY HH24:MI'));
    DBMS_OUTPUT.PUT_LINE('Cliente: ' || v_orden.nombre_cliente);
    DBMS_OUTPUT.PUT_LINE('Email: ' || v_orden.email_cliente);
    DBMS_OUTPUT.PUT_LINE('Total: $' || v_orden.total);
    DBMS_OUTPUT.PUT_LINE('Estado: ' || v_orden.estado);
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Orden no encontrada');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;
/

/* =============================================
   VARRAY: Tags/Etiquetas del Producto
   ============================================= */

CREATE OR REPLACE TYPE TagsArray AS VARRAY(10) OF VARCHAR2(50);
/
ALTER TABLE productos ADD (
    tags TagsArray
);

-- 3. INSERTAR PRODUCTO CON TAGS
UPDATE productos
SET tags = TagsArray(
    'gaming',
    'laptop',
    'alta-gama',
    'rtx',
    'intel',
    'rgb',
    'portatil'
)
WHERE id = 1;

-- 4. BUSCAR PRODUCTOS POR TAG
SELECT 
    p.id,
    p.nombre,
    p.precio
FROM productos p,
     TABLE(p.tags) t
WHERE LOWER(t.COLUMN_VALUE) = 'gaming';

-- 5. LISTAR TODOS LOS TAGS
SELECT DISTINCT
    t.COLUMN_VALUE AS tag,
    COUNT(*) AS total_productos
FROM productos p,
     TABLE(p.tags) t
GROUP BY t.COLUMN_VALUE
ORDER BY COUNT(*) DESC;

-- 6. EJEMPLO PL/SQL: Sistema de BÃºsqueda
DECLARE
    v_busqueda VARCHAR2(50) := 'gaming';
    
    CURSOR c_productos IS
        SELECT p.id, p.nombre, p.precio, p.tags
        FROM productos p,
             TABLE(p.tags) t
        WHERE LOWER(t.COLUMN_VALUE) = LOWER(v_busqueda);
BEGIN
    DBMS_OUTPUT.PUT_LINE('=== PRODUCTOS CON TAG: "' || v_busqueda || '" ===');
    DBMS_OUTPUT.PUT_LINE('');
    
    FOR prod IN c_productos LOOP
        DBMS_OUTPUT.PUT_LINE('ğŸ”¹ ' || prod.nombre || ' - $' || prod.precio);
        
        -- Mostrar todos los tags
        DBMS_OUTPUT.PUT_LINE('  Tags: ');
        FOR i IN 1..prod.tags.COUNT LOOP
            DBMS_OUTPUT.PUT_LINE('    â€¢ ' || prod.tags(i));
        END LOOP;
        DBMS_OUTPUT.PUT_LINE('');
    END LOOP;
END;
/

-- cursor simple implicito
BEGIN
    DBMS_OUTPUT.PUT_LINE('=== USUARIOS REGISTRADOS ===');
    DBMS_OUTPUT.PUT_LINE('');
    
    -- FOR implÃ­citamente abre, recorre y cierra el cursor
    FOR usuario IN (
        SELECT id, nombre, email
        FROM usuarios
        ORDER BY id
    ) LOOP
        DBMS_OUTPUT.PUT_LINE('   Usuario ' || usuario.nombre);
        DBMS_OUTPUT.PUT_LINE('   Email: ' || usuario.email);
        DBMS_OUTPUT.PUT_LINE('   ID: ' || usuario.id);
        DBMS_OUTPUT.PUT_LINE('');
    END LOOP;
    
END;
/

-- cursor explicito
DECLARE
    CURSOR c_productos_bajo_stock IS
        SELECT id, nombre, stock, precio
        FROM productos
        WHERE stock < 1000 AND activo = 1
        ORDER BY stock ASC;
BEGIN
    FOR prod IN c_productos_bajo_stock LOOP
        DBMS_OUTPUT.PUT_LINE('   Nombre: ' || prod.nombre || ' - Stock: ' || prod.stock);
    END LOOP;
END;
/



-- Cursor con parÃ¡metros

DECLARE
    CURSOR c_productos_categoria(
        p_categoria IN VARCHAR2,            
        p_precio_min IN NUMBER DEFAULT 0,
        p_precio_max IN NUMBER DEFAULT 999999
    ) IS
        SELECT 
            id,
            nombre,
            precio,
            stock,
            categoria                         
        FROM productos
        WHERE categoria = p_categoria         
          AND precio BETWEEN p_precio_min AND p_precio_max
          AND stock > 0
          AND activo = 1                      
        ORDER BY precio ASC;
    
    v_contador NUMBER := 0;
    
BEGIN
    FOR prod IN c_productos_categoria('Laptos', 0, 1000000) LOOP
        
        v_contador := v_contador + 1;
        
        DBMS_OUTPUT.PUT_LINE('   v_contador '|| '. ' || prod.nombre);
        DBMS_OUTPUT.PUT_LINE('   CategorÃ­a: ' || prod.categoria);
        DBMS_OUTPUT.PUT_LINE('   Precio: $' || prod.precio);
        DBMS_OUTPUT.PUT_LINE('   Stock: ' || prod.stock || ' unidades');
        DBMS_OUTPUT.PUT_LINE('');
        
    END LOOP;
    
    IF v_contador = 0 THEN
        DBMS_OUTPUT.PUT_LINE('  No se encontraron productos en esa categorÃ­a');
    ELSE
        DBMS_OUTPUT.PUT_LINE('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
        DBMS_OUTPUT.PUT_LINE('Total productos encontrados: ' || v_contador);
    END IF;
    
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
        
END;
/


-- CURSOR COMPLEJO

DECLARE
    CURSOR c_reporte_ordenes IS
        SELECT 
            o.id,
            o.total,
            o.estado,
            TO_CHAR(o.creado_en, 'DD/MM/YYYY HH24:MI') AS fecha,
            u.nombre AS cliente,
            u.email,
            (SELECT COUNT(*) FROM orden_items oi WHERE oi.orden_id = o.id) AS items
        FROM ordenes o
        JOIN usuarios u ON o.usuario_id = u.id
        WHERE o.estado IN ('CREADA', 'ENVIADA')
        ORDER BY o.creado_en DESC;
    
    v_total NUMBER := 0;
    v_contador NUMBER := 0;
    
BEGIN
    DBMS_OUTPUT.PUT_LINE('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
    DBMS_OUTPUT.PUT_LINE('â•‘        REPORTE DE Ã“RDENES COMPLETADAS              â•‘');
    DBMS_OUTPUT.PUT_LINE('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    DBMS_OUTPUT.PUT_LINE('');
    
    FOR orden IN c_reporte_ordenes LOOP
        v_contador := v_contador + 1;
        v_total := v_total + orden.total;
        
        DBMS_OUTPUT.PUT_LINE('   Orden #' || orden.id || ' - ' || orden.estado);
        DBMS_OUTPUT.PUT_LINE('   Cliente: ' || orden.cliente || ' (' || orden.email || ')');
        DBMS_OUTPUT.PUT_LINE('   Fecha: ' || orden.fecha);
        DBMS_OUTPUT.PUT_LINE('   Items: ' || orden.items);
        DBMS_OUTPUT.PUT_LINE('   Total: $' || orden.total);
        DBMS_OUTPUT.PUT_LINE('');
        
    END LOOP;
    
    DBMS_OUTPUT.PUT_LINE('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    DBMS_OUTPUT.PUT_LINE('Total Ã³rdenes: ' || v_contador);
    DBMS_OUTPUT.PUT_LINE('Total facturado: $' || v_total);
    
    IF v_contador > 0 THEN
        DBMS_OUTPUT.PUT_LINE('Promedio: $' || ROUND(v_total / v_contador, 2));
    END IF;
    
END;
/

-- expeciones

CREATE OR REPLACE PROCEDURE sp_validar_y_descontar_stock(
    p_producto_id IN NUMBER,
    p_cantidad IN NUMBER
) IS
    e_stock_insuficiente EXCEPTION;
    
    v_stock NUMBER;
    v_nombre VARCHAR2(180);
    
BEGIN
    SELECT nombre, stock
    INTO v_nombre, v_stock
    FROM productos
    WHERE id = p_producto_id AND activo = 1
    FOR UPDATE;  
    
    -- Validar stock
    IF p_cantidad > v_stock THEN
        RAISE e_stock_insuficiente;
    END IF;
    
    -- Descontar stock
    UPDATE productos
    SET stock = stock - p_cantidad,
        actualizado_en = SYSTIMESTAMP
    WHERE id = p_producto_id;
    
    COMMIT;
    
    DBMS_OUTPUT.PUT_LINE('Stock descontado exitosamente');
    DBMS_OUTPUT.PUT_LINE('Producto: ' || v_nombre);
    DBMS_OUTPUT.PUT_LINE('Nuevo stock: ' || (v_stock - p_cantidad));
    
EXCEPTION
    WHEN e_stock_insuficiente THEN
        ROLLBACK;  -- Revertir solo si hay error
        RAISE_APPLICATION_ERROR(-20001, 
            'Stock insuficiente para ' || v_nombre || 
            '. Disponible: ' || v_stock || ', Solicitado: ' || p_cantidad);
            
    WHEN NO_DATA_FOUND THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20003, 
            'Producto no encontrado o inactivo');
            
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
/

/* =============================================
   PRUEBA CORRECTA: Capturar Excepciones
   ============================================= */

BEGIN
    DBMS_OUTPUT.PUT_LINE('===============================================');
    DBMS_OUTPUT.PUT_LINE('INTENTANDO DESCONTAR UNIDADES...');
    DBMS_OUTPUT.PUT_LINE('===============================================');
    DBMS_OUTPUT.PUT_LINE('');
    
    sp_validar_y_descontar_stock(1, 99999);
    
    DBMS_OUTPUT.PUT_LINE('Operacion completada');
    
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('');
        DBMS_OUTPUT.PUT_LINE('===============================================');
        DBMS_OUTPUT.PUT_LINE('ERROR CAPTURADO:');
        DBMS_OUTPUT.PUT_LINE('===============================================');
        DBMS_OUTPUT.PUT_LINE(SQLERRM); 
        DBMS_OUTPUT.PUT_LINE('');
        DBMS_OUTPUT.PUT_LINE('Codigo de error: ' || SQLCODE);
        DBMS_OUTPUT.PUT_LINE('===============================================');
END;
/

-- Funciones

CREATE OR REPLACE FUNCTION fn_stock_disponible_varchar(
    p_producto_id IN NUMBER,
    p_cantidad_requerida IN NUMBER
) RETURN VARCHAR2 IS
    v_stock_actual NUMBER;
    v_activo NUMBER;
BEGIN
    -- Obtener stock y estado del producto
    SELECT stock, activo
    INTO v_stock_actual, v_activo
    FROM productos
    WHERE id = p_producto_id;
    
    -- Validar que este activo
    IF v_activo = 0 THEN
        RETURN 'INACTIVO';
    ELSIF v_stock_actual >= p_cantidad_requerida THEN
        RETURN 'DISPONIBLE';
    ELSE
        RETURN 'INSUFICIENTE';
    END IF;
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 'NO_EXISTE';
    WHEN OTHERS THEN
        RETURN 'ERROR';
END;
/

-- Probar la funciÃ³n
-- Ver disponibilidad de primeros 5 productos
SELECT 
    id,
    nombre,
    stock,
    activo,
    fn_stock_disponible_varchar(id, 10) AS stock_10_unidades,
    fn_stock_disponible_varchar(id, 100) AS stock_100_unidades
FROM productos
WHERE ROWNUM <= 5;

-- funcion calcular subtotal

CREATE OR REPLACE FUNCTION fn_calcular_subtotal_orden(
    p_orden_id IN NUMBER
) RETURN NUMBER IS
    v_subtotal NUMBER := 0;
BEGIN
    -- Sumar todos los items de la orden
    SELECT SUM(cantidad * producto_precio)
    INTO v_subtotal
    FROM orden_items
    WHERE orden_id = p_orden_id;
    
    -- Retornar 0 si no hay items o es NULL
    RETURN NVL(v_subtotal, 0);
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 0;
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20100, 
            'Error al calcular subtotal de orden #' || p_orden_id || ': ' || SQLERRM);
END;
/

-- Probar la funciÃ³n
SELECT fn_calcular_subtotal_orden(1) AS subtotal
FROM dual;

-- TRIGGERS
--  ActualizaciÃ³n AutomÃ¡tica de Stock

CREATE OR REPLACE TRIGGER trg_actualizar_stock_orden
AFTER INSERT ON orden_items
FOR EACH ROW
DECLARE
    v_stock_actual NUMBER;
    v_nombre_producto VARCHAR2(180);
    e_stock_insuficiente EXCEPTION;
BEGIN
    -- Obtener stock actual y nombre del producto
    SELECT stock, nombre
    INTO v_stock_actual, v_nombre_producto
    FROM productos
    WHERE id = :NEW.producto_id
    FOR UPDATE;
    
    -- Validacion
    IF v_stock_actual < :NEW.cantidad THEN
        RAISE e_stock_insuficiente;
    END IF;
    
    -- Actualizar stock
    UPDATE productos
    SET stock = stock - :NEW.cantidad,
        actualizado_en = SYSTIMESTAMP
    WHERE id = :NEW.producto_id;
    
    -- Log de la operaciÃ³n
    DBMS_OUTPUT.PUT_LINE('Stock actualizado para: ' || v_nombre_producto);
    DBMS_OUTPUT.PUT_LINE('Cantidad descontada: ' || :NEW.cantidad);
    DBMS_OUTPUT.PUT_LINE('Stock anterior: ' || v_stock_actual);
    DBMS_OUTPUT.PUT_LINE('Stock nuevo: ' || (v_stock_actual - :NEW.cantidad));
    
EXCEPTION
    WHEN e_stock_insuficiente THEN
        RAISE_APPLICATION_ERROR(-20010, 
            'Stock insuficiente para ' || v_nombre_producto || 
            '. Disponible: ' || v_stock_actual || 
            ', Solicitado: ' || :NEW.cantidad);
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20011, 
            'Producto con ID ' || :NEW.producto_id || ' no encontrado');
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20012, 
            'Error al actualizar stock: ' || SQLERRM);
END;
/

-- TRIGGER DE AUDITORIA DE ORDENES

CREATE OR REPLACE TRIGGER trg_auditoria_ordenes
AFTER INSERT OR UPDATE OR DELETE ON ordenes
FOR EACH ROW
DECLARE
    v_operacion VARCHAR2(20);
    v_usuario VARCHAR2(100);
    v_ip VARCHAR2(50);
BEGIN
    -- Determinar el tipo de operaciÃ³n
    IF INSERTING THEN
        v_operacion := 'INSERT';
    ELSIF UPDATING THEN
        v_operacion := 'UPDATE';
    ELSIF DELETING THEN
        v_operacion := 'DELETE';
    END IF;
    
    -- Obtener usuario 
    SELECT USER INTO v_usuario FROM DUAL;
    
    -- Obtener IP del cliente (si estÃ¡ disponible)
    BEGIN
        SELECT SYS_CONTEXT('USERENV', 'IP_ADDRESS')
        INTO v_ip
        FROM DUAL;
    EXCEPTION
        WHEN OTHERS THEN
            v_ip := 'No disponible';
    END;
    
    -- Insertar registro 
    IF INSERTING THEN
        INSERT INTO auditoria_ordenes (
            orden_id,
            operacion,
            usuario_bd,
            fecha_operacion,
            estado_nuevo,
            total_nuevo,
            ip_cliente,
            observaciones
        ) VALUES (
            :NEW.id,
            v_operacion,
            v_usuario,
            SYSTIMESTAMP,
            :NEW.estado,
            :NEW.total,
            v_ip,
            'Orden creada'
        );
        
    ELSIF UPDATING THEN
        INSERT INTO auditoria_ordenes (
            orden_id,
            operacion,
            usuario_bd,
            fecha_operacion,
            estado_anterior,
            estado_nuevo,
            total_anterior,
            total_nuevo,
            ip_cliente,
            observaciones
        ) VALUES (
            :NEW.id,
            v_operacion,
            v_usuario,
            SYSTIMESTAMP,
            :OLD.estado,
            :NEW.estado,
            :OLD.total,
            :NEW.total,
            v_ip,
            CASE 
                WHEN :OLD.estado != :NEW.estado THEN 'Cambio de estado: ' || :OLD.estado || ' -> ' || :NEW.estado
                WHEN :OLD.total != :NEW.total THEN 'Cambio de total: ' || :OLD.total || ' -> ' || :NEW.total
                ELSE 'Orden modificada'
            END
        );
        
    ELSIF DELETING THEN
        INSERT INTO auditoria_ordenes (
            orden_id,
            operacion,
            usuario_bd,
            fecha_operacion,
            estado_anterior,
            total_anterior,
            ip_cliente,
            observaciones
        ) VALUES (
            :OLD.id,
            v_operacion,
            v_usuario,
            SYSTIMESTAMP,
            :OLD.estado,
            :OLD.total,
            v_ip,
            'Orden eliminada'
        );
    END IF;
    
    -- Log en consola
    DBMS_OUTPUT.PUT_LINE('=======================================');
    DBMS_OUTPUT.PUT_LINE('AUDITORIA: ' || v_operacion || ' en orden #' || 
        CASE 
            WHEN DELETING THEN :OLD.id 
            ELSE :NEW.id 
        END);
    DBMS_OUTPUT.PUT_LINE('Usuario: ' || v_usuario);
    DBMS_OUTPUT.PUT_LINE('Fecha: ' || TO_CHAR(SYSTIMESTAMP, 'DD/MM/YYYY HH24:MI:SS'));
    DBMS_OUTPUT.PUT_LINE('=======================================');
    
EXCEPTION
    WHEN OTHERS THEN
        -- No lanzar error para no interrumpir la operaciÃ³n principal
        DBMS_OUTPUT.PUT_LINE('Error en auditorÃ­a: ' || SQLERRM);
END;
/

-- TRIGGER validacion de eliminacion.

CREATE OR REPLACE TRIGGER trg_validar_eliminacion_producto
BEFORE DELETE ON productos
FOR EACH ROW
DECLARE
    v_ordenes_activas NUMBER;
    v_total_ordenes NUMBER;
    e_producto_en_uso EXCEPTION;
BEGIN
    -- Contar Ã³rdenes activas con este producto
    SELECT COUNT(DISTINCT oi.orden_id)
    INTO v_ordenes_activas
    FROM orden_items oi
    JOIN ordenes o ON oi.orden_id = o.id
    WHERE oi.producto_id = :OLD.id
      AND o.estado IN ('CREADA', 'ENVIADA', 'PROCESANDO');
    
    -- Si hay Ã³rdenes activas, no permitir eliminaciÃ³n
    IF v_ordenes_activas > 0 THEN
        RAISE e_producto_en_uso;
    END IF;
    
    -- Contar total de Ã³rdenes (incluyendo completadas)
    SELECT COUNT(DISTINCT orden_id)
    INTO v_total_ordenes
    FROM orden_items
    WHERE producto_id = :OLD.id;
    
    -- Advertencia si hay Ã³rdenes completadas
    IF v_total_ordenes > 0 THEN
        DBMS_OUTPUT.PUT_LINE('=======================================');
        DBMS_OUTPUT.PUT_LINE('ADVERTENCIA:');
        DBMS_OUTPUT.PUT_LINE('El producto "' || :OLD.nombre || '" estÃ¡ en ' || 
            v_total_ordenes || ' orden(es) histÃ³rica(s).');
        DBMS_OUTPUT.PUT_LINE('Se permite la eliminaciÃ³n porque no hay Ã³rdenes activas.');
        DBMS_OUTPUT.PUT_LINE('=======================================');
    END IF;
    
    -- Log de eliminaciÃ³n permitida
    DBMS_OUTPUT.PUT_LINE('Producto "' || :OLD.nombre || '" eliminado correctamente.');
    
EXCEPTION
    WHEN e_producto_en_uso THEN
        RAISE_APPLICATION_ERROR(-20020, 
            'No se puede eliminar el producto "' || :OLD.nombre || 
            '" porque estÃ¡ en ' || v_ordenes_activas || 
            ' orden(es) activa(s). Estados: CREADA, ENVIADA, PROCESANDO. ' ||
            'Primero complete o cancele estas Ã³rdenes.');
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20021, 
            'Error al validar eliminaciÃ³n del producto: ' || SQLERRM);
END;
/

-- Verificar que se creÃ³
SELECT trigger_name, status, trigger_type, triggering_event
FROM user_triggers
WHERE trigger_name = 'TRG_VALIDAR_ELIMINACION_PRODUCTO';


-- LOOP ANIDADO 

DECLARE
    CURSOR c_ordenes IS
        SELECT 
            o.id,
            o.total,
            o.estado,
            TO_CHAR(o.creado_en, 'DD/MM/YYYY') AS fecha,
            u.nombre AS cliente
        FROM ordenes o
        JOIN usuarios u ON o.usuario_id = u.id
        WHERE o.estado = 'CREADA'
        ORDER BY o.creado_en DESC;
    
    CURSOR c_items(p_orden_id NUMBER) IS
        SELECT 
            oi.id,
            oi.producto_nombre,
            oi.cantidad,
            oi.producto_precio,
            (oi.cantidad * oi.producto_precio) AS subtotal
        FROM orden_items oi
        WHERE oi.orden_id = p_orden_id
        ORDER BY oi.id;
    
    v_total_items NUMBER;
    v_subtotal_orden NUMBER;
    
BEGIN
    DBMS_OUTPUT.PUT_LINE('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
    DBMS_OUTPUT.PUT_LINE('â•‘     REPORTE DETALLADO: Ã“RDENES CON ITEMS          â•‘');
    DBMS_OUTPUT.PUT_LINE('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    DBMS_OUTPUT.PUT_LINE('');
    
    -- LOOP EXTERNO: Recorrer Ã³rdenes
    FOR orden IN c_ordenes LOOP
        v_total_items := 0;
        v_subtotal_orden := 0;
        
        DBMS_OUTPUT.PUT_LINE('â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
        DBMS_OUTPUT.PUT_LINE('â”‚ Orden #' || orden.id || ' - ' || orden.estado);
        DBMS_OUTPUT.PUT_LINE('â”‚ Cliente: ' || orden.cliente);
        DBMS_OUTPUT.PUT_LINE('â”‚ Fecha: ' || orden.fecha);
        DBMS_OUTPUT.PUT_LINE('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤');
        DBMS_OUTPUT.PUT_LINE('â”‚ ITEMS:');
        
        -- LOOP INTERNO: Recorrer items de la orden
        FOR item IN c_items(orden.id) LOOP
            v_total_items := v_total_items + 1;
            v_subtotal_orden := v_subtotal_orden + item.subtotal;
            
            DBMS_OUTPUT.PUT_LINE('â”‚   ' || v_total_items || '. ' || item.producto_nombre);
            DBMS_OUTPUT.PUT_LINE('â”‚      Cantidad: ' || item.cantidad || 
                                 ' x $' || item.producto_precio || 
                                 ' = $' || item.subtotal);
        END LOOP;
        
        DBMS_OUTPUT.PUT_LINE('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤');
        DBMS_OUTPUT.PUT_LINE('â”‚ Total Items: ' || v_total_items);
        DBMS_OUTPUT.PUT_LINE('â”‚ Subtotal: $' || v_subtotal_orden);
        DBMS_OUTPUT.PUT_LINE('â”‚ Total Orden: $' || orden.total);
        DBMS_OUTPUT.PUT_LINE('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜');
        DBMS_OUTPUT.PUT_LINE('');
        
    END LOOP;
    
END;
/